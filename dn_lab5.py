# -*- coding: utf-8 -*-
"""DN_lab5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13BoM1mj5Qd4rqhJ9AJmq9KWoK-gFMhZL
"""

import torch
import torch.nn as nn
import torchvision
import torchvision.transforms as transforms
import os
from torchvision.models import resnet18, ResNet18_Weights

device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
print(f"Используется устройство: {device}")

transform = transforms.Compose([
    transforms.Resize((64, 64)),
    transforms.ToTensor(),
])

from google.colab import drive
drive.mount('/content/drive')

data_dir = '/content/drive/MyDrive/your_folder/data'
train_dir = os.path.join(data_dir, 'train')
test_dir = os.path.join(data_dir, 'test')

if not os.path.exists(train_dir):
    print("Скачивание примера датасета...")
    train_data = torchvision.datasets.CIFAR10(
        root='./data',
        train=True,
        download=True,
        transform=transform
    )
    test_data = torchvision.datasets.CIFAR10(
        root='./data',
        train=False,
        download=True,
        transform=transform
    )
    num_classes = 10
    print(f"Используется CIFAR-10, количество классов: {num_classes}")
else:
    train_data = torchvision.datasets.ImageFolder(train_dir, transform=transform)
    test_data = torchvision.datasets.ImageFolder(test_dir, transform=transform)
    num_classes = len(train_data.classes)
    print(f"Классы: {train_data.classes}")
    print(f"Количество классов: {num_classes}")

train_loader = torch.utils.data.DataLoader(train_data, batch_size=16, shuffle=True)
test_loader = torch.utils.data.DataLoader(test_data, batch_size=16, shuffle=False)

class MyCNN(nn.Module):
    def __init__(self, num_classes):
        super().__init__()
        self.conv1 = nn.Conv2d(3, 16, 3, padding=1)
        self.pool = nn.MaxPool2d(2)
        self.conv2 = nn.Conv2d(16, 32, 3, padding=1)
        self.fc = nn.Linear(32 * 16 * 16, num_classes)

    def forward(self, x):
        x = self.pool(torch.relu(self.conv1(x)))
        x = self.pool(torch.relu(self.conv2(x)))
        x = x.view(x.size(0), -1)
        return self.fc(x)

model1 = MyCNN(num_classes).to(device)
optimizer1 = torch.optim.Adam(model1.parameters(), lr=0.001)
criterion = nn.CrossEntropyLoss()

for epoch in range(10):
    model1.train()
    total_loss = 0
    for images, labels in train_loader:
        images, labels = images.to(device), labels.to(device)
        optimizer1.zero_grad()
        outputs = model1(images)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer1.step()
        total_loss += loss.item()
    print(f'CNN Эпоха {epoch+1}, Loss: {total_loss/len(train_loader):.4f}')

model1.eval()
correct1 = total = 0
with torch.no_grad():
    for images, labels in test_loader:
        images, labels = images.to(device), labels.to(device)
        outputs = model1(images)
        _, predicted = torch.max(outputs, 1)
        total += labels.size(0)
        correct1 += (predicted == labels).sum().item()

print(f'CNN Точность: {100*correct1/total:.1f}%')
torch.save(model1.state_dict(), 'my_cnn_model.pth')

model2 = resnet18(weights=ResNet18_Weights.IMAGENET1K_V1)
for param in model2.parameters():
    param.requires_grad = False

model2.fc = nn.Linear(model2.fc.in_features, num_classes)
model2 = model2.to(device)
optimizer2 = torch.optim.Adam(model2.fc.parameters(), lr=0.001)

for epoch in range(15):
    model2.train()
    total_loss = 0
    for images, labels in train_loader:
        images, labels = images.to(device), labels.to(device)
        optimizer2.zero_grad()
        outputs = model2(images)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer2.step()
        total_loss += loss.item()
    print(f'ResNet Эпоха {epoch+1}, Loss: {total_loss/len(train_loader):.4f}')

model2.eval()
correct2 = total = 0
with torch.no_grad():
    for images, labels in test_loader:
        images, labels = images.to(device), labels.to(device)
        outputs = model2(images)
        _, predicted = torch.max(outputs, 1)
        total += labels.size(0)
        correct2 += (predicted == labels).sum().item()

print(f'ResNet Точность: {100*correct2/total:.1f}%')
torch.save(model2.state_dict(), 'pretrained_resnet_model.pth')

drive_path = '/content/drive/MyDrive/models/'
os.makedirs(drive_path, exist_ok=True)
torch.save(model1.state_dict(), os.path.join(drive_path, 'my_cnn_model.pth'))
torch.save(model2.state_dict(), os.path.join(drive_path, 'pretrained_resnet_model.pth'))
print(f"Модели сохранены в {drive_path}")