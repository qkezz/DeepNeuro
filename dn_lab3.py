# -*- coding: utf-8 -*-
"""DN_lab3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-Mabz1b6YpY3pDlOCSr9AWyox43bAWWn
"""

import torch
import random

x = torch.randint(0, 300, (1,))
xfloat = x.to(dtype=torch.float32)
xfloat.requires_grad_(True)

n = 3
power_result = xfloat ** n
s = random.randint(1, 10)
g = xfloat * s
e = torch.exp(g)
f = xfloat ** n

f.backward()
print(f'x = {xfloat.item()}')
print(f'x^3 = {power_result.item()}')
print(f'g = x * {s} = {g.item()}')
print(f'exp(g) = {e.item()}')
print(f'Производная x^3: {xfloat.grad.item()}')
print(f'Проверка 3*x^2 = {3 * (xfloat.item() ** 2)}')

import torch
import numpy as np
import pandas as pd
import torch.nn as nn

df = pd.read_csv('/content/drive/MyDrive/iris.csv', delimiter=',')
X = df.iloc[:, [0, 1, 2, 3]].values
Y = df.iloc[:, 4].values
Y = np.where(Y == 'Iris-setosa', 1, -1)

X_tensor = torch.tensor(X, dtype=torch.float32)
Y_tensor = torch.tensor(Y, dtype=torch.float32)

model = nn.Linear(4, 1)
criterion = nn.MSELoss()
optimizer = torch.optim.SGD(model.parameters(), lr=0.01)

output = model(X_tensor)
loss = criterion(output, Y_tensor.reshape(-1, 1))
optimizer.zero_grad()
loss.backward()
optimizer.step()

print(f'Loss: {loss.item():.4f}')

with torch.no_grad():
    predictions = model(X_tensor)
    predicted_labels = torch.where(predictions >= 0, 1, -1)
    accuracy = (predicted_labels.flatten() == Y_tensor).float().mean()
    print(f'Accuracy: {accuracy.item()*100:.2f}%')
    print(f'Weights: {model.weight}')
    print(f'Bias: {model.bias}')